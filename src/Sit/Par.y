-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Sit.Par where
import Sit.Abs
import Sit.Lex
import Sit.ErrM

}

%name pPrg Prg
%name pDecl Decl
%name pQualId QualId
%name pListDecl ListDecl
%name pIdU IdU
%name pBind Bind
%name pListBind ListBind
%name pListIdent ListIdent
%name pListIdU ListIdU
%name pExp2 Exp2
%name pExp Exp
%name pExp1 Exp1
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '+' { PT _ (TS _ 3) }
  '--;' { PT _ (TS _ 4) }
  '->' { PT _ (TS _ 5) }
  '.' { PT _ (TS _ 6) }
  '..' { PT _ (TS _ 7) }
  ':' { PT _ (TS _ 8) }
  ';' { PT _ (TS _ 9) }
  '=' { PT _ (TS _ 10) }
  'Nat' { PT _ (TS _ 11) }
  'Set' { PT _ (TS _ 12) }
  'Set1' { PT _ (TS _ 13) }
  'Set2' { PT _ (TS _ 14) }
  'Size' { PT _ (TS _ 15) }
  '\\' { PT _ (TS _ 16) }
  '_' { PT _ (TS _ 17) }
  'case' { PT _ (TS _ 18) }
  'fix' { PT _ (TS _ 19) }
  'forall' { PT _ (TS _ 20) }
  'import' { PT _ (TS _ 21) }
  'lsuc' { PT _ (TS _ 22) }
  'lzero' { PT _ (TS _ 23) }
  'of' { PT _ (TS _ 24) }
  'oo' { PT _ (TS _ 25) }
  'open' { PT _ (TS _ 26) }
  'return' { PT _ (TS _ 27) }
  'suc' { PT _ (TS _ 28) }
  'zero' { PT _ (TS _ 29) }
  '{' { PT _ (TS _ 30) }
  '}' { PT _ (TS _ 31) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }

Prg :: { Prg }
Prg : ListDecl { Sit.Abs.Prg $1 }
Decl :: { Decl }
Decl : Ident ':' Exp { Sit.Abs.Sig $1 $3 }
     | Ident '=' Exp { Sit.Abs.Def $1 $3 }
     | 'open' 'import' QualId { Sit.Abs.Open $3 }
     | {- empty -} { Sit.Abs.Blank }
QualId :: { QualId }
QualId : Ident { Sit.Abs.Sg $1 }
       | QualId '.' Ident { Sit.Abs.Cons $1 $3 }
ListDecl :: { [Decl] }
ListDecl : Decl { (:[]) $1 } | Decl '--;' ListDecl { (:) $1 $3 }
IdU :: { IdU }
IdU : Ident { Sit.Abs.Id $1 } | '_' { Sit.Abs.Under }
Bind :: { Bind }
Bind : '.' Ident { Sit.Abs.BIrrel $2 }
     | '..' Ident { Sit.Abs.BRel $2 }
     | '(' ListIdent ':' Exp ')' { Sit.Abs.BAnn $2 $4 }
ListBind :: { [Bind] }
ListBind : Bind { (:[]) $1 } | Bind ListBind { (:) $1 $2 }
ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ListIdent { (:) $1 $2 }
ListIdU :: { [IdU] }
ListIdU : IdU { (:[]) $1 } | IdU ListIdU { (:) $1 $2 }
Exp2 :: { Exp }
Exp2 : IdU { Sit.Abs.Var $1 }
     | Integer { Sit.Abs.Int $1 }
     | 'oo' { Sit.Abs.Infty }
     | 'Nat' { Sit.Abs.Nat }
     | 'Set' { Sit.Abs.Set }
     | 'Set1' { Sit.Abs.Set1 }
     | 'Set2' { Sit.Abs.Set2 }
     | 'zero' { Sit.Abs.Zero }
     | 'suc' { Sit.Abs.Suc }
     | 'fix' { Sit.Abs.Fix }
     | 'lzero' { Sit.Abs.LZero }
     | 'lsuc' { Sit.Abs.LSuc }
     | '(' Exp ')' { $2 }
Exp :: { Exp }
Exp : '\\' ListIdU '->' Exp { Sit.Abs.Lam $2 $4 }
    | 'forall' ListBind '->' Exp { Sit.Abs.Forall $2 $4 }
    | '(' Exp ':' Exp ')' '->' Exp { Sit.Abs.Pi $2 $4 $7 }
    | Exp1 '->' Exp { Sit.Abs.Arrow $1 $3 }
    | 'case' Exp 'return' Exp 'of' Exp { Sit.Abs.Case $2 $4 $6 }
    | Exp1 '+' Integer { Sit.Abs.Plus $1 $3 }
    | '\\' '{' '(' 'zero' '_' ')' '->' Exp ';' '(' 'suc' '_' IdU ')' '->' Exp '}' { Sit.Abs.ELam $8 $13 $16 }
    | Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp1 Exp2 { Sit.Abs.App $1 $2 } | Exp2 { $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

